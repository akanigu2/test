-- Type Soul GUI: ESP + WalkSpeed + NoClip + Hitbox Expansion + GUI Toggle (Auto Parry removed)
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")

local localPlayer        = Players.LocalPlayer
local camera             = workspace.CurrentCamera
local drawingObjects     = {}

local espEnabled         = true
local noclipEnabled      = false
local hitboxEnabled      = false
local guiVisible         = true

local normalSpeed        = 16 -- normal Type Soul walk speed
local maxSpeedMultiplier = 5
local currentMultiplier  = 1
local floatPart          = nil
local hitboxScale        = 4 -- 4x normal size

local function getChar()
    return localPlayer.Character or localPlayer.CharacterAdded:Wait()
end

-- GUI Setup
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.ResetOnSpawn = false

-- ESP Toggle
local espToggle = Instance.new("TextButton", gui)
espToggle.Size = UDim2.new(0, 100, 0, 40)
espToggle.Position = UDim2.new(0, 10, 0, 10)
espToggle.Text = "ESP: ON"
espToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
espToggle.TextColor3 = Color3.new(1, 1, 1)
espToggle.BorderSizePixel = 0

espToggle.MouseButton1Click:Connect(function()
    espEnabled = not espEnabled
    espToggle.Text = espEnabled and "ESP: ON" or "ESP: OFF"
    for _, obj in pairs(drawingObjects) do
        for _, draw in pairs(obj) do
            draw.Visible = false
        end
    end
end)

-- NoClip Toggle
local noclipToggle = Instance.new("TextButton", gui)
noclipToggle.Size = UDim2.new(0, 120, 0, 40)
noclipToggle.Position = UDim2.new(0, 120, 0, 10)
noclipToggle.Text = "NoClip: OFF"
noclipToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
noclipToggle.TextColor3 = Color3.new(1, 1, 1)
noclipToggle.BorderSizePixel = 0

noclipToggle.MouseButton1Click:Connect(function()
    noclipEnabled = not noclipEnabled
    noclipToggle.Text = noclipEnabled and "NoClip: ON" or "NoClip: OFF"

    if noclipEnabled then
        if not floatPart then
            floatPart = Instance.new("Part")
            floatPart.Size = Vector3.new(6, 1, 6)
            floatPart.Anchored = true
            floatPart.Transparency = 1
            floatPart.CanCollide = true
            floatPart.Parent = workspace
        end
    else
        if floatPart then
            floatPart:Destroy()
            floatPart = nil
        end
    end
end)

-- Hitbox Expansion Toggle
local hitboxToggle = Instance.new("TextButton", gui)
hitboxToggle.Size = UDim2.new(0, 140, 0, 40)
hitboxToggle.Position = UDim2.new(0, 250, 0, 10)
hitboxToggle.Text = "Hitbox: OFF"
hitboxToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
hitboxToggle.TextColor3 = Color3.new(1, 1, 1)
hitboxToggle.BorderSizePixel = 0

hitboxToggle.MouseButton1Click:Connect(function()
    hitboxEnabled = not hitboxEnabled
    hitboxToggle.Text = hitboxEnabled and "Hitbox: ON" or "Hitbox: OFF"
end)

-- WalkSpeed Slider
local sliderFrame = Instance.new("Frame", gui)
sliderFrame.Size = UDim2.new(0, 200, 0, 60)
sliderFrame.Position = UDim2.new(0, 10, 0, 60)
sliderFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.15)
sliderFrame.BorderSizePixel = 0

local speedLabel = Instance.new("TextLabel", sliderFrame)
speedLabel.Size = UDim2.new(1, 0, 0, 20)
speedLabel.Position = UDim2.new(0, 0, 0, 0)
speedLabel.BackgroundTransparency = 1
speedLabel.TextColor3 = Color3.new(1, 1, 1)
speedLabel.Text = "WalkSpeed: 1.0x"

local sliderBar = Instance.new("Frame", sliderFrame)
sliderBar.Size = UDim2.new(1, -20, 0, 10)
sliderBar.Position = UDim2.new(0, 10, 0, 30)
sliderBar.BackgroundColor3 = Color3.new(0.3, 0.3, 0.3)
sliderBar.BorderSizePixel = 0

local sliderKnob = Instance.new("Frame", sliderBar)
sliderKnob.Size = UDim2.new(0, 10, 1, 0)
sliderKnob.Position = UDim2.new(0, 0, 0, 0)
sliderKnob.BackgroundColor3 = Color3.new(1, 1, 1)
sliderKnob.BorderSizePixel = 0

local dragging = false
local function setSpeedFromSlider()
    local pct = math.clamp(sliderKnob.Position.X.Scale, 0, 1)
    currentMultiplier = 1 + (maxSpeedMultiplier - 1) * pct
    speedLabel.Text = ("WalkSpeed: %.1fx"):format(currentMultiplier)
end

sliderKnob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local absX = input.Position.X
        local barX = sliderBar.AbsolutePosition.X
        local barW = sliderBar.AbsoluteSize.X
        local pct = math.clamp((absX - barX) / barW, 0, 1)
        sliderKnob.Position = UDim2.new(pct, -5, 0, 0)
        setSpeedFromSlider()
    end
end)

-- Keybind: Toggle GUI (Right Ctrl)
UserInputService.InputBegan:Connect(function(input, gpe)
    if input.KeyCode == Enum.KeyCode.RightControl and not gpe then
        gui.Enabled = not gui.Enabled
    end
end)

-- Persistent WalkSpeed + NoClip enforcement + Hitbox expansion
RunService.Stepped:Connect(function()
    local char = getChar()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        local isRunning = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
        hum.WalkSpeed = isRunning and normalSpeed or normalSpeed * currentMultiplier

        if noclipEnabled then
            for _, p in pairs(char:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = false end
            end
            if floatPart then
                floatPart.Position = char.HumanoidRootPart.Position - Vector3.new(0, 3.5, 0)
            end
        end
    end

    if hitboxEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Size = Vector3.new(2, 2, 1) * hitboxScale
                    hrp.Transparency = 0.5
                    hrp.CanCollide = false
                end
            end
        end
    end
end)

-- ESP setup
local function createEsp(player)
    if player == localPlayer or drawingObjects[player] then return end
    local name = Drawing.new("Text")
    local hp   = Drawing.new("Text")
    local dist = Drawing.new("Text")

    name.Size, name.Outline, name.Center, name.Visible = 14, true, true, false
    hp.Size,   hp.Outline,   hp.Center,   hp.Visible   = 13, true, true, false
    dist.Size, dist.Outline, dist.Center, dist.Visible = 13, true, true, false
    hp.Color = Color3.new(1, 0, 0)

    drawingObjects[player] = {name = name, health = hp, dist = dist}
end

Players.PlayerRemoving:Connect(function(player)
    local d = drawingObjects[player]
    if d then for _, obj in pairs(d) do obj:Remove() end end
    drawingObjects[player] = nil
end)

RunService.RenderStepped:Connect(function()
    if not espEnabled then return end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
            if hrp and hum and hum.Health > 0 then
                createEsp(player)
                local s, visible = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0))
                local d = drawingObjects[player]
                if visible then
                    d.name.Text = player.Name .. " [" .. tostring(player.Team) .. "]"
                    d.name.Position = Vector2.new(s.X, s.Y)
                    d.name.Color = player.TeamColor.Color
                    d.name.Visible = true

                    d.health.Text = "HP: " .. math.floor(hum.Health) .. "/" .. math.floor(hum.MaxHealth)
                    d.health.Position = Vector2.new(s.X, s.Y + 15)
                    d.health.Visible = true

                    local dist = (getChar().HumanoidRootPart.Position - hrp.Position).Magnitude
                    d.dist.Text = "Dist: " .. math.floor(dist)
                    d.dist.Position = Vector2.new(s.X, s.Y + 30)
                    d.dist.Visible = true
                else
                    d.name.Visible, d.health.Visible, d.dist.Visible = false, false, false
                end
            end
        end
    end
end)
