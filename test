-- Type Soul GUI: ESP + WalkSpeed + NoClip + Fly + GUI Toggle
-- Features:
--  • ESP (name by team, HP, distance)
--  • WalkSpeed slider (min = normalSpeed, max = 5x)
--  • NoClip toggle (safe float part)
--  • Fly toggle + fly speed slider (max = 10)
--  • GUI hide/show with RightCtrl
--  • Sprint behavior preserved (script leaves sprint alone at 1x; modifies when >= 2x)

local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")

local localPlayer        = Players.LocalPlayer
local camera             = workspace.CurrentCamera
local drawingObjects     = {}

-- Toggles / settings
local espEnabled         = true
local noclipEnabled      = false
local flyEnabled         = false

local normalSpeed        = 16 -- minimum walk speed
local maxSpeedMultiplier = 5
local currentMultiplier  = 1

local maxFlySpeed        = 10
local flySpeed           = 5

local floatPart          = nil
local flyBV              = nil
local flyBG              = nil

local function getChar()
    return localPlayer.Character or localPlayer.CharacterAdded:Wait()
end

-- GUI
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.ResetOnSpawn = false

-- Row positions
local baseX = 10
local y1 = 10
local y2 = 60

-- ESP Toggle
local espToggle = Instance.new("TextButton", gui)
espToggle.Size = UDim2.new(0, 100, 0, 40)
espToggle.Position = UDim2.new(0, baseX, 0, y1)
espToggle.Text = "ESP: ON"
espToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
espToggle.TextColor3 = Color3.new(1, 1, 1)
espToggle.BorderSizePixel = 0
espToggle.MouseButton1Click:Connect(function()
    espEnabled = not espEnabled
    espToggle.Text = espEnabled and "ESP: ON" or "ESP: OFF"
    for _, obj in pairs(drawingObjects) do
        for _, draw in pairs(obj) do draw.Visible = false end
    end
end)

-- NoClip Toggle
local noclipToggle = Instance.new("TextButton", gui)
noclipToggle.Size = UDim2.new(0, 120, 0, 40)
noclipToggle.Position = UDim2.new(0, baseX + 110, 0, y1)
noclipToggle.Text = "NoClip: OFF"
noclipToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
noclipToggle.TextColor3 = Color3.new(1, 1, 1)
noclipToggle.BorderSizePixel = 0
noclipToggle.MouseButton1Click:Connect(function()
    noclipEnabled = not noclipEnabled
    noclipToggle.Text = noclipEnabled and "NoClip: ON" or "NoClip: OFF"
    if noclipEnabled then
        if not floatPart then
            floatPart = Instance.new("Part")
            floatPart.Size = Vector3.new(6, 1, 6)
            floatPart.Anchored = true
            floatPart.Transparency = 1
            floatPart.CanCollide = true
            floatPart.Parent = workspace
        end
    else
        if floatPart then floatPart:Destroy(); floatPart = nil end
    end
end)

-- Fly Toggle
local flyToggle = Instance.new("TextButton", gui)
flyToggle.Size = UDim2.new(0, 100, 0, 40)
flyToggle.Position = UDim2.new(0, baseX + 240, 0, y1)
flyToggle.Text = "Fly: OFF"
flyToggle.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
flyToggle.TextColor3 = Color3.new(1, 1, 1)
flyToggle.BorderSizePixel = 0
flyToggle.MouseButton1Click:Connect(function()
    flyEnabled = not flyEnabled
    flyToggle.Text = flyEnabled and "Fly: ON" or "Fly: OFF"

    local char = getChar()
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if flyEnabled then
        if hrp then
            -- create BodyVelocity and BodyGyro
            flyBV = Instance.new("BodyVelocity")
            flyBV.MaxForce = Vector3.new(1e5, 1e5, 1e5)
            flyBV.P = 1250
            flyBV.Velocity = Vector3.new(0,0,0)
            flyBV.Parent = hrp

            flyBG = Instance.new("BodyGyro")
            flyBG.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
            flyBG.P = 3000
            flyBG.CFrame = hrp.CFrame
            flyBG.Parent = hrp
        end
        if hum then hum.PlatformStand = true end
    else
        if flyBV then flyBV:Destroy(); flyBV = nil end
        if flyBG then flyBG:Destroy(); flyBG = nil end
        if hum then hum.PlatformStand = false end
    end
end)

-- WalkSpeed Slider UI
local walkFrame = Instance.new("Frame", gui)
walkFrame.Size = UDim2.new(0, 200, 0, 60)
walkFrame.Position = UDim2.new(0, baseX, 0, y2)
walkFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.15)
walkFrame.BorderSizePixel = 0

local speedLabel = Instance.new("TextLabel", walkFrame)
speedLabel.Size = UDim2.new(1,0,0,20)
speedLabel.Position = UDim2.new(0,0,0,0)
speedLabel.BackgroundTransparency = 1
speedLabel.TextColor3 = Color3.new(1,1,1)
speedLabel.Text = "WalkSpeed: 1.0x"

local sliderBar = Instance.new("Frame", walkFrame)
sliderBar.Size = UDim2.new(1, -20, 0, 10)
sliderBar.Position = UDim2.new(0, 10, 0, 30)
sliderBar.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
sliderBar.BorderSizePixel = 0

local sliderKnob = Instance.new("Frame", sliderBar)
sliderKnob.Size = UDim2.new(0, 10, 1, 0)
sliderKnob.Position = UDim2.new(0, 0, 0, 0)
sliderKnob.BackgroundColor3 = Color3.new(1,1,1)
sliderKnob.BorderSizePixel = 0

local walkingDragging = false
local function setSpeedFromSlider()
    local pct = math.clamp(sliderKnob.Position.X.Scale, 0, 1)
    currentMultiplier = 1 + (maxSpeedMultiplier - 1) * pct
    speedLabel.Text = ("WalkSpeed: %.1fx"):format(currentMultiplier)
end

sliderKnob.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then walkingDragging = true end end)
UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then walkingDragging = false end end)
UserInputService.InputChanged:Connect(function(input)
    if walkingDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local absX = input.Position.X
        local barX = sliderBar.AbsolutePosition.X
        local barW = sliderBar.AbsoluteSize.X
        local pct = math.clamp((absX - barX) / barW, 0, 1)
        sliderKnob.Position = UDim2.new(pct, -5, 0, 0)
        setSpeedFromSlider()
    end
end)

-- Fly Speed Slider UI
local flyFrame = Instance.new("Frame", gui)
flyFrame.Size = UDim2.new(0, 200, 0, 60)
flyFrame.Position = UDim2.new(0, baseX + 220, 0, y2)
flyFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.15)
flyFrame.BorderSizePixel = 0

local flyLabel = Instance.new("TextLabel", flyFrame)
flyLabel.Size = UDim2.new(1,0,0,20)
flyLabel.Position = UDim2.new(0,0,0,0)
flyLabel.BackgroundTransparency = 1
flyLabel.TextColor3 = Color3.new(1,1,1)
flyLabel.Text = ("Fly Speed: %.1f"):format(flySpeed)

local flyBar = Instance.new("Frame", flyFrame)
flyBar.Size = UDim2.new(1, -20, 0, 10)
flyBar.Position = UDim2.new(0, 10, 0, 30)
flyBar.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
flyBar.BorderSizePixel = 0

local flyKnob = Instance.new("Frame", flyBar)
flyKnob.Size = UDim2.new(0, 10, 1, 0)
local initFlyPct = math.clamp((flySpeed / maxFlySpeed), 0, 1)
flyKnob.Position = UDim2.new(initFlyPct, -5, 0, 0)
flyKnob.BackgroundColor3 = Color3.new(1,1,1)
flyKnob.BorderSizePixel = 0

local flyingDragging = false
local function setFlySpeedFromSlider()
    local pct = math.clamp(flyKnob.Position.X.Scale, 0, 1)
    flySpeed = 1 + (maxFlySpeed - 1) * pct -- min 1, max maxFlySpeed
    flyLabel.Text = ("Fly Speed: %.1f"):format(flySpeed)
end

flyKnob.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then flyingDragging = true end end)
UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then flyingDragging = false end end)
UserInputService.InputChanged:Connect(function(input)
    if flyingDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local absX = input.Position.X
        local barX = flyBar.AbsolutePosition.X
        local barW = flyBar.AbsoluteSize.X
        local pct = math.clamp((absX - barX) / barW, 0, 1)
        flyKnob.Position = UDim2.new(pct, -5, 0, 0)
        setFlySpeedFromSlider()
    end
end)

-- Keybind: Toggle GUI (Right Ctrl)
UserInputService.InputBegan:Connect(function(input, gpe)
    if input.KeyCode == Enum.KeyCode.RightControl and not gpe then
        gui.Enabled = not gui.Enabled
    end
end)

-- Movement / enforcement loop
RunService.Stepped:Connect(function()
    local char = getChar()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hum then
        -- WalkSpeed logic (preserve sprint when multiplier == 1)
        local isRunning = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
        local desiredSpeed = nil
        if isRunning then
            if currentMultiplier >= 2 then
                desiredSpeed = normalSpeed * currentMultiplier
            else
                desiredSpeed = nil -- do not touch sprint speed when multiplier == 1
            end
        else
            desiredSpeed = normalSpeed * currentMultiplier
        end
        if desiredSpeed and hum.WalkSpeed < desiredSpeed then
            hum.WalkSpeed = desiredSpeed
        end

        -- NoClip enforcement + float part position
        if noclipEnabled then
            for _, p in pairs(char:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = false end
            end
            if floatPart and hrp then
                floatPart.Position = hrp.Position - Vector3.new(0, 3.5, 0)
            end
        end

        -- Fly enforcement
        if flyEnabled and hrp then
            -- Ensure body movers exist (in case created elsewhere)
            if not flyBV or not flyBV.Parent then
                flyBV = Instance.new("BodyVelocity")
                flyBV.MaxForce = Vector3.new(1e5, 1e5, 1e5)
                flyBV.P = 1250
                flyBV.Parent = hrp
            end
            if not flyBG or not flyBG.Parent then
                flyBG = Instance.new("BodyGyro")
                flyBG.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
                flyBG.P = 3000
                flyBG.Parent = hrp
            end

            -- Get movement input
            local moveVec = Vector3.new(0,0,0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + Vector3.new(0,0,-1) end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec + Vector3.new(0,0,1) end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec + Vector3.new(-1,0,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + Vector3.new(1,0,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveVec = moveVec + Vector3.new(0,-1,0) end

            local velocity = Vector3.new(0,0,0)
            if moveVec.Magnitude > 0 then
                local cam = workspace.CurrentCamera
                local forward = Vector3.new(cam.CFrame.LookVector.X, 0, cam.CFrame.LookVector.Z).Unit
                local right = Vector3.new(cam.CFrame.RightVector.X, 0, cam.CFrame.RightVector.Z).Unit
                local vertical = Vector3.new(0,1,0)
                local dir = (forward * -moveVec.Z) + (right * moveVec.X) + (vertical * moveVec.Y)
                if dir.Magnitude > 0 then
                    velocity = dir.Unit * flySpeed
                end
            else
                velocity = Vector3.new(0,0,0)
            end

            flyBV.Velocity = velocity
            flyBG.CFrame = hrp.CFrame
            -- keep PlatformStand true to prevent normal physics interference
            hum.PlatformStand = true
        else
            -- if fly disabled, ensure movers removed and PlatformStand off
            if flyBV then flyBV:Destroy(); flyBV = nil end
            if flyBG then flyBG:Destroy(); flyBG = nil end
            if hum.PlatformStand then hum.PlatformStand = false end
        end
    end
end)

-- ESP (Drawing) setup and loop
local function createEsp(player)
    if player == localPlayer or drawingObjects[player] then return end
    local name = Drawing.new("Text")
    local hp   = Drawing.new("Text")
    local dist = Drawing.new("Text")

    name.Size, name.Outline, name.Center, name.Visible = 14, true, true, false
    hp.Size,   hp.Outline,   hp.Center,   hp.Visible   = 13, true, true, false
    dist.Size, dist.Outline, dist.Center, dist.Visible = 13, true, true, false
    hp.Color = Color3.new(1, 0, 0)

    drawingObjects[player] = {name = name, health = hp, dist = dist}
end

Players.PlayerRemoving:Connect(function(player)
    local d = drawingObjects[player]
    if d then for _, obj in pairs(d) do obj:Remove() end end
    drawingObjects[player] = nil
end)

RunService.RenderStepped:Connect(function()
    if not espEnabled then return end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
            if hrp and hum and hum.Health > 0 then
                createEsp(player)
                local sPos, onScreen = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0,3,0))
                local d = drawingObjects[player]
                if onScreen then
                    d.name.Text = player.Name .. " [" .. tostring(player.Team) .. "]"
                    d.name.Position = Vector2.new(sPos.X, sPos.Y)
                    d.name.Color = player.TeamColor.Color
                    d.name.Visible = true

                    d.health.Text = "HP: " .. math.floor(hum.Health) .. "/" .. math.floor(hum.MaxHealth)
                    d.health.Position = Vector2.new(sPos.X, sPos.Y + 15)
                    d.health.Visible = true

                    local myHRP = getChar():FindFirstChild("HumanoidRootPart")
                    local distVal = myHRP and (myHRP.Position - hrp.Position).Magnitude or 0
                    d.dist.Text = "Dist: " .. math.floor(distVal)
                    d.dist.Position = Vector2.new(sPos.X, sPos.Y + 30)
                    d.dist.Visible = true
                else
                    d.name.Visible, d.health.Visible, d.dist.Visible = false, false, false
                end
            end
        end
    end
end)
